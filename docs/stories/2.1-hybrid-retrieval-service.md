# Story 2.1: Hybrid Retrieval Service Implementation

## Status
Not Started

## Epic
Epic 2: Core RAG Query System

## Dependencies
- Epic 1 must be complete (vector database populated, BM25 index built)
- Existing repositories: `VectorRepository`, `BM25Repository`
- Existing infrastructure: SQLite, Alembic, structlog

## Story
**As a** developer,
**I want** a hybrid retrieval service that combines vector similarity search and BM25 keyword matching,
**so that** I can retrieve the most relevant chunks for both conceptual and exact-match queries.

## Acceptance Criteria

### Core Functionality
1. `HybridRetrievalService` class created in `src/rag/hybrid_retrieval.py`
2. Vector search integration with `VectorRepository`:
   - Accepts query embedding (1536-dim vector)
   - Returns top-k chunks with similarity scores
   - Supports async operations
3. BM25 search integration with `BM25Repository`:
   - Accepts query text string
   - Returns top-k chunks with BM25 scores
   - Supports async operations

### Parallel Execution
4. Parallel retrieval execution:
   - Vector and BM25 searches run concurrently using `asyncio.gather()`
   - Performance: Both complete within combined time (not sequential)

### Reciprocal Rank Fusion
5. Reciprocal Rank Fusion (RRF) algorithm implementation:
   - Combines vector and BM25 results into unified ranking
   - Formula: `score = Σ 1/(k + rank_i)` where k=60 (standard RRF constant)
   - Returns final top-k chunks with fused scores

### Configuration
6. Configuration via environment:
   - `RETRIEVAL_TOP_K` (default: 20)
   - `RETRIEVAL_VECTOR_WEIGHT` (default: 0.5)
   - `RETRIEVAL_BM25_WEIGHT` (default: 0.5)

### Observability
7. Structured logging with timing metrics:
   - Vector search latency
   - BM25 search latency
   - Fusion processing time
   - Total retrieval time

### CLI Command
8. CLI command for testing hybrid retrieval:
   - Command: `poetry run retrieve <query_text>`
   - Generates embedding from query text
   - Executes hybrid retrieval
   - Displays top results with scores and article titles

### Testing
9. Unit tests covering:
   - Happy path: Both retrievals return results
   - Edge case: Vector returns results, BM25 returns none (and vice versa)
   - Edge case: Both return empty results
   - RRF algorithm correctness with known inputs
   - Async execution timing validation

## Tasks / Subtasks

- [ ] Task 1: Create HybridRetrievalService class structure (AC: 1)
  - [ ] Create `src/rag/` module with `__init__.py`
  - [ ] Create `src/rag/hybrid_retrieval.py`
  - [ ] Define `HybridRetrievalService` class with dependency injection
  - [ ] Add initialization with VectorRepository and BM25Repository
  - [ ] Add configuration loading from environment

- [ ] Task 2: Implement vector search integration (AC: 2)
  - [ ] Create `async def _vector_search()` method
  - [ ] Call `VectorRepository.search_by_embedding()`
  - [ ] Handle and log vector search errors
  - [ ] Return chunks with similarity scores

- [ ] Task 3: Implement BM25 search integration (AC: 3)
  - [ ] Create `async def _bm25_search()` method
  - [ ] Call `BM25Repository.search()`
  - [ ] Handle and log BM25 search errors
  - [ ] Return chunks with BM25 scores

- [ ] Task 4: Implement parallel execution (AC: 4)
  - [ ] Create main `async def retrieve()` method
  - [ ] Use `asyncio.gather()` to run both searches concurrently
  - [ ] Add timing instrumentation for both searches
  - [ ] Log latency for each search method

- [ ] Task 5: Implement RRF fusion algorithm (AC: 5)
  - [ ] Create `_fuse_results()` method
  - [ ] Implement RRF scoring formula (k=60)
  - [ ] Handle ranking for chunks appearing in both result sets
  - [ ] Sort by fused score and return top-k chunks
  - [ ] Add structured logging for fusion metrics

- [ ] Task 6: Add configuration support (AC: 6)
  - [ ] Load `RETRIEVAL_TOP_K` from environment
  - [ ] Load `RETRIEVAL_VECTOR_WEIGHT` from environment
  - [ ] Load `RETRIEVAL_BM25_WEIGHT` from environment
  - [ ] Document environment variables in `.env.example`

- [ ] Task 7: Create CLI command for hybrid retrieval (AC: 8)
  - [ ] Create `src/cli/retrieve.py` with retrieve command
  - [ ] Load vector store and BM25 repository
  - [ ] Generate embedding from query text using OpenAI
  - [ ] Execute hybrid retrieval and display results
  - [ ] Add command to pyproject.toml console scripts

- [ ] Task 8: Write unit tests (AC: 9)
  - [ ] Test happy path with both retrievals returning results
  - [ ] Test vector-only results (BM25 returns empty)
  - [ ] Test BM25-only results (vector returns empty)
  - [ ] Test both searches return empty results
  - [ ] Test RRF algorithm with known inputs/expected outputs
  - [ ] Test async execution timing (parallel vs sequential)
  - [ ] Mock VectorRepository and BM25Repository

- [ ] Task 9: Integration testing
  - [ ] Test with real VectorRepository and BM25Repository (test collection)
  - [ ] Verify latency targets (<100ms for retrieval)
  - [ ] Verify RRF improves ranking quality

## Dev Notes

### Technical Background
- **RRF Effectiveness:** Proven to improve retrieval quality by 15-30% for mixed query types
- **Latency Target:** <100ms for retrieval (critical for user experience)
- **BM25 Strength:** Proper noun handling (character names, factions)
- **Vector Strength:** Conceptual/semantic queries

### RRF Algorithm
```python
def reciprocal_rank_fusion(
    results: list[tuple[str, float]],
    k: int = 60
) -> dict[str, float]:
    """
    Compute RRF scores for search results.

    Args:
        results: List of (chunk_id, score) tuples
        k: RRF constant (default: 60, standard value)

    Returns:
        Dict mapping chunk_id to RRF score
    """
    scores = {}
    for rank, (chunk_id, _) in enumerate(results, start=1):
        rrf_score = 1.0 / (k + rank)
        scores[chunk_id] = scores.get(chunk_id, 0) + rrf_score
    return scores
```

### Parallel Execution Pattern
```python
async def retrieve(self, query_embedding: list[float], query_text: str) -> list[WikiChunk]:
    """Execute hybrid retrieval with parallel execution."""
    # Run searches concurrently
    vector_results, bm25_results = await asyncio.gather(
        self._vector_search(query_embedding),
        self._bm25_search(query_text)
    )

    # Fuse results
    fused_chunks = self._fuse_results(vector_results, bm25_results)
    return fused_chunks
```

### Environment Configuration
Add to `.env.example`:
```bash
# Hybrid Retrieval Configuration
RETRIEVAL_TOP_K=20                    # Number of chunks to retrieve
RETRIEVAL_VECTOR_WEIGHT=0.5           # Weight for vector search (0-1)
RETRIEVAL_BM25_WEIGHT=0.5             # Weight for BM25 search (0-1)
```

### Relevant Source Tree
```
src/rag/
├── __init__.py                       # NEW: RAG module exports
├── hybrid_retrieval.py               # NEW: HybridRetrievalService
src/repositories/
├── vector_repository.py              # EXISTING: VectorRepository
├── bm25_repository.py                # EXISTING: BM25Repository
tests/unit/
├── test_hybrid_retrieval.py          # NEW: Unit tests
tests/integration/
├── test_rag_pipeline.py              # NEW: Integration tests
```

### Testing Strategy
- **Unit Tests:** Mock repositories to test fusion logic and error handling
- **Integration Tests:** Use test Chroma collection and real BM25 index
- **Performance Tests:** Verify parallel execution timing improvements

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-05 | 1.0 | Story created from Epic 2 | John (PM Agent) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Pull Request
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_

---

**Estimated Effort:** 3 hours
