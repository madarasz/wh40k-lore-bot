# Story 1.9: Metadata Extraction from Content

## Status
Draft

## Story
**As a** developer,
**I want** to extract metadata (faction, era, character names, links) from chunk content,
**so that** I can enable rich filtering and enhance retrieval relevance.

## Acceptance Criteria
1. `src/ingestion/metadata_extractor.py` created with `MetadataExtractor` class
2. Faction detection:
   - Keyword matching from predefined list: `FACTIONS = ["Space Marines", "Tyranids", "Orks", ...]`
   - Case-insensitive matching
   - Return most frequent faction mentioned in chunk
3. Era detection:
   - Keyword matching: `ERAS = ["Great Crusade", "Horus Heresy", "Age of Apostasy", ...]`
   - Return all eras mentioned
4. Character name extraction:
   - Use internal wiki links: `[[Roboute Guilliman]]` â†’ "Roboute Guilliman"
   - Limit to top 5 most mentioned
5. Content type classification:
   - "lore" (default)
   - "military" (keywords: battle, war, tactics)
   - "technology" (keywords: weapon, armor, vehicle)
   - "character" (if character names dominate)
6. Spoiler detection:
   - Keyword matching: "spoiler", "recent lore", "9th edition", "10th edition"
   - Default: `False` (Fandom wiki is canon, not spoilers)
7. Source book extraction:
   - Regex for book titles in references: "Codex: Space Marines", "Horus Heresy: Betrayal"
8. `extract_metadata(chunk: Chunk) -> Dict` method returns all metadata fields
9. Unit tests with sample chunks covering each detection case
10. Integration test with real wiki chunks

## Tasks / Subtasks

- [ ] Create MetadataExtractor class (AC: 1)
  - [ ] Create src/ingestion/metadata_extractor.py
  - [ ] Implement MetadataExtractor class
  - [ ] Add structlog logger instance
  - [ ] Add type hints and docstring
- [ ] Define faction and era constants (AC: 2, 3)
  - [ ] Create src/common/constants.py
  - [ ] Define FACTIONS list with major factions:
    - Space Marines, Chaos Space Marines, Imperial Guard
    - Tyranids, Orks, Eldar, Dark Eldar, Tau
    - Necrons, Adeptus Mechanicus, Sisters of Battle
    - (Add more from lore knowledge)
  - [ ] Define ERAS list with major timeline periods:
    - Age of Terra, Age of Strife, Great Crusade
    - Horus Heresy, The Scouring, Age of Redemption
    - Age of Apostasy, Age of Forging, Time of Ending
    - (Add more from lore knowledge)
- [ ] Implement faction detection (AC: 2)
  - [ ] Implement _detect_faction(text: str) -> Optional[str]
  - [ ] Convert text to lowercase for matching
  - [ ] Search for each faction keyword in text
  - [ ] Count occurrences of each faction
  - [ ] Return most frequent faction (or None)
  - [ ] Handle faction aliases (e.g., "Astra Militarum" = "Imperial Guard")
- [ ] Implement era detection (AC: 3)
  - [ ] Implement _detect_eras(text: str) -> List[str]
  - [ ] Convert text to lowercase for matching
  - [ ] Search for each era keyword in text
  - [ ] Return all eras mentioned
  - [ ] Deduplicate results
- [ ] Implement character name extraction (AC: 4)
  - [ ] Implement _extract_character_names(text: str) -> List[str]
  - [ ] Extract wiki links from markdown: [[Name]]
  - [ ] Use regex: r'\[\[([^\]|]+)(?:\|[^\]]+)?\]\]'
  - [ ] Filter for likely character names (proper nouns)
  - [ ] Count mentions of each character
  - [ ] Return top 5 most mentioned
- [ ] Implement content type classification (AC: 5)
  - [ ] Implement _classify_content_type(text: str, character_names: List[str]) -> str
  - [ ] Define keyword sets for each type:
    - military: ["battle", "war", "tactics", "campaign", "siege"]
    - technology: ["weapon", "armor", "vehicle", "tech", "equipment"]
    - character: (high character name density)
  - [ ] Count keyword matches for each type
  - [ ] Return type with highest score
  - [ ] Default to "lore" if no clear match
- [ ] Implement spoiler detection (AC: 6)
  - [ ] Implement _detect_spoiler(text: str) -> bool
  - [ ] Define spoiler keywords:
    - "spoiler", "recent lore", "latest edition"
    - "9th edition", "10th edition", "current timeline"
  - [ ] Search for keywords (case-insensitive)
  - [ ] Return True if any found, False otherwise
  - [ ] Default: False
- [ ] Implement source book extraction (AC: 7)
  - [ ] Implement _extract_source_books(text: str) -> List[str]
  - [ ] Define regex patterns for book titles:
    - r'Codex:\s*([^,.\n]+)'
    - r'Horus Heresy:\s*([^,.\n]+)'
    - r'Index:\s*([^,.\n]+)'
    - r'White Dwarf\s+(\d+)'
  - [ ] Extract all matches
  - [ ] Deduplicate and clean results
  - [ ] Return list of source books
- [ ] Implement main extraction method (AC: 8)
  - [ ] Implement extract_metadata(chunk: Chunk) -> Dict
  - [ ] Call all detection methods
  - [ ] Combine results into metadata dict
  - [ ] Include fields:
    - faction: Optional[str]
    - era: Optional[str] (or List[str])
    - character_names: List[str]
    - content_type: str
    - spoiler_flag: bool
    - source_books: List[str]
  - [ ] Return complete metadata dict
- [ ] Write unit tests (AC: 9)
  - [ ] Create tests/unit/test_metadata_extractor.py
  - [ ] Test faction detection with various chunks
  - [ ] Test era detection
  - [ ] Test character name extraction from wiki links
  - [ ] Test content type classification (each type)
  - [ ] Test spoiler detection (true and false cases)
  - [ ] Test source book extraction
  - [ ] Test extract_metadata returns all fields
  - [ ] Test edge cases (empty text, no matches)
- [ ] Write integration test (AC: 10)
  - [ ] Create tests/integration/test_metadata_extraction.py
  - [ ] Test with real wiki chunks
  - [ ] Verify faction detection accuracy
  - [ ] Verify character names extracted correctly
  - [ ] Log metadata extraction statistics
- [ ] Verify all acceptance criteria met
  - [ ] Run all tests with `poetry run pytest`
  - [ ] Test with sample chunks from various factions
  - [ ] Verify metadata quality

## Dev Notes

### Previous Story Insights
Story 1.8 completed:
- Chroma vector store ready
- Metadata schema defined
- Ready to populate metadata fields

### Technical Notes
**[Source: Epic 1 Story 1.9]**

- Simple keyword-based approach (no LLM needed for MVP)
- Faction/era lists maintained in `src/common/constants.py`
- Character names extracted from internal links (reliable)

### Faction List (Sample)

```python
FACTIONS = [
    # Imperium
    "Space Marines", "Adeptus Astartes",
    "Imperial Guard", "Astra Militarum",
    "Adeptus Mechanicus",
    "Adeptus Custodes",
    "Sisters of Battle", "Adepta Sororitas",
    "Imperial Navy",
    "Inquisition",

    # Chaos
    "Chaos Space Marines",
    "Death Guard",
    "Thousand Sons",
    "World Eaters",
    "Emperor's Children",
    "Chaos Daemons",

    # Xenos
    "Tyranids",
    "Orks",
    "Eldar", "Aeldari",
    "Dark Eldar", "Drukhari",
    "Tau", "T'au Empire",
    "Necrons",
    "Genestealer Cults",

    # Add more...
]
```

### Era List (Sample)

```python
ERAS = [
    "Age of Terra",
    "Age of Strife",
    "Unification Wars",
    "Great Crusade",
    "Horus Heresy",
    "The Scouring",
    "Age of Redemption",
    "Age of Apostasy",
    "Age of Forging",
    "Time of Ending",
    "Indomitus Crusade",
    # Add more...
]
```

### Character Name Extraction

```python
import re

def extract_character_names(text: str) -> List[str]:
    # Extract wiki links: [[Name]] or [[Name|Display]]
    pattern = r'\[\[([^\]|]+)(?:\|[^\]]+)?\]\]'
    matches = re.findall(pattern, text)

    # Count mentions
    from collections import Counter
    counter = Counter(matches)

    # Return top 5
    return [name for name, count in counter.most_common(5)]
```

### Content Type Classification

```python
CONTENT_TYPE_KEYWORDS = {
    "military": ["battle", "war", "warfare", "campaign", "siege", "tactics", "strategy"],
    "technology": ["weapon", "armor", "vehicle", "tech", "equipment", "bolter", "power armor"],
}

def classify_content_type(text: str, character_names: List[str]) -> str:
    text_lower = text.lower()

    # Check character density
    if len(character_names) >= 3:
        return "character"

    # Score each type
    scores = {}
    for content_type, keywords in CONTENT_TYPE_KEYWORDS.items():
        scores[content_type] = sum(1 for kw in keywords if kw in text_lower)

    # Return type with highest score
    if max(scores.values()) > 0:
        return max(scores, key=scores.get)

    return "lore"  # Default
```

### Source Book Regex Patterns

```python
SOURCE_BOOK_PATTERNS = [
    r'Codex:\s*([^,.\n]+)',
    r'Index:\s*([^,.\n]+)',
    r'Horus Heresy:\s*Book\s+(\d+)[:\s]*([^,.\n]+)',
    r'White Dwarf\s+(\d+)',
    r'Campaign Book:\s*([^,.\n]+)',
]
```

### Coding Standards Reminders

**[Source: architecture/coding-standards.md]**
- Type hints required for all function signatures
- Docstrings required for all public functions (Google style)
- Constants in UPPER_CASE (FACTIONS, ERAS)
- Use regex for pattern matching
- Handle edge cases gracefully (empty strings, no matches)

## Dev Agent Record

### Agent Model Used
[To be populated during implementation]

### Debug Log References
[To be populated during implementation]

### Completion Notes List
[To be populated during implementation]

### File List
[To be populated during implementation]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-26 | 1.0 | Story created from Epic 1 | Bob (Scrum Master) |

## QA Results
[To be populated by QA agent]
