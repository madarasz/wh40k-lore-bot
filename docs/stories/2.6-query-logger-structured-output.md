# Story 2.6: Query Logger with Structured Output Fields

## Status
Not Started

## Epic
Epic 2: Core RAG Query System

## Dependencies
- Story 2.5: Query Orchestrator (`QueryRequest`, `QueryResponse`)
- Existing SQLAlchemy + Alembic infrastructure from Epic 1
- Existing structlog infrastructure

## Story
**As a** developer,
**I want** a query logging system that asynchronously records all query attempts with structured output metadata (personality, smalltalk flag, sources),
**so that** I can analyze usage patterns, smalltalk vs lore ratios, debug issues, and track API costs.

## Acceptance Criteria

### QueryLog SQLAlchemy Model
1. `QueryLog` SQLAlchemy model created in `src/models/query_log.py`:
   - `id`: UUID (primary key)
   - `timestamp`: DateTime (indexed)
   - `user_id`: String (nullable, indexed)
   - `server_id`: String (nullable, indexed)
   - `query_text`: Text
   - `response_text`: Text (nullable, answer field from LLM)
   - **NEW:** `personality_reply`: Text (nullable, personality addition from LLM)
   - **NEW:** `smalltalk`: Boolean (default: False, indexed for analytics)
   - **NEW:** `source_urls`: Text (nullable, JSON array of wiki URLs)
   - `chunks_retrieved`: JSON (list of chunk IDs)
   - `retrieval_scores`: JSON (list of scores)
   - `llm_provider`: String
   - `llm_model`: String
   - `llm_tokens_prompt`: Integer
   - `llm_tokens_completion`: Integer
   - `llm_cost_usd`: Float
   - `latency_retrieval_ms`: Integer
   - `latency_llm_ms`: Integer
   - `latency_total_ms`: Integer
   - `error_occurred`: Boolean
   - `error_message`: Text (nullable)

### Alembic Migration
2. Alembic migration created for `query_logs` table:
   - Indexes on: `timestamp DESC`, `user_id`, `server_id`, `error_occurred`, `smalltalk`
   - Backward compatible (additive only)
   - Run migration as part of story

### QueryLogRepository
3. `QueryLogRepository` class in `src/repositories/query_log_repository.py`:
   - Repository pattern implementation
   - `async def create(log: QueryLog) -> QueryLog`
   - `async def get_recent(limit: int = 100) -> List[QueryLog]`
   - `async def get_by_user(user_id: str, limit: int = 50) -> List[QueryLog]`
   - `async def get_by_server(server_id: str, limit: int = 50) -> List[QueryLog]`
   - `async def get_error_logs(limit: int = 50) -> List[QueryLog]`
   - **NEW:** `async def get_smalltalk_queries(limit: int = 50) -> List[QueryLog]`
   - **NEW:** `async def get_lore_queries(limit: int = 50) -> List[QueryLog]`

### QueryLogger Service
4. `QueryLogger` service in `src/services/query_logger.py`:
   - `async def log_query(query_request: QueryRequest, query_response: QueryResponse) -> None`
   - Converts request/response into QueryLog model
   - Maps structured output fields: personality_reply, smalltalk, source_urls
   - Serializes source_urls list to JSON string
   - Saves via QueryLogRepository
   - Asynchronous execution (non-blocking via `asyncio.create_task()`)
   - Error handling: Log failures don't crash main query flow

### Orchestrator Integration
5. Integration with `QueryOrchestrator`:
   - Add `QueryLogger` as dependency
   - Call `query_logger.log_query()` after query completes (success or failure)
   - Fire-and-forget pattern (don't await logging)

### Service Logging
6. Structured logging for query logger itself:
   - Log when query log saved successfully
   - Include smalltalk flag in log message
   - Log errors if database write fails

### Testing
7. Unit tests covering:
   - QueryLog model creation with new fields
   - Field validation (personality_reply, smalltalk, source_urls)
   - QueryLogRepository CRUD operations
   - QueryLogRepository: Query by smalltalk flag (get_smalltalk_queries, get_lore_queries)
   - QueryLogger service: Successful logging with structured fields
   - QueryLogger service: Database error handling (doesn't crash)
   - Async logging doesn't block query response
   - Alembic migration up/down

## Tasks / Subtasks

- [ ] Task 1: Create QueryLog model (AC: 1)
  - [ ] Create `src/models/query_log.py`
  - [ ] Define `QueryLog` SQLAlchemy model
  - [ ] Add all fields with proper types
  - [ ] Add `personality_reply`, `smalltalk`, `source_urls` fields
  - [ ] Export from `src/models/__init__.py`

- [ ] Task 2: Create Alembic migration (AC: 2)
  - [ ] Run `poetry run alembic revision --autogenerate -m "add_query_logs_table"`
  - [ ] Review generated migration
  - [ ] Add indexes: `timestamp DESC`, `user_id`, `server_id`, `error_occurred`, `smalltalk`
  - [ ] Run `poetry run alembic upgrade head`
  - [ ] Verify table created correctly

- [ ] Task 3: Create QueryLogRepository (AC: 3)
  - [ ] Create `src/repositories/query_log_repository.py`
  - [ ] Implement `create()` method
  - [ ] Implement `get_recent()` method
  - [ ] Implement `get_by_user()` method
  - [ ] Implement `get_by_server()` method
  - [ ] Implement `get_error_logs()` method
  - [ ] Implement `get_smalltalk_queries()` method
  - [ ] Implement `get_lore_queries()` method
  - [ ] Export from `src/repositories/__init__.py`

- [ ] Task 4: Create QueryLogger service (AC: 4)
  - [ ] Create `src/services/query_logger.py`
  - [ ] Implement `log_query()` method
  - [ ] Map QueryRequest/QueryResponse to QueryLog
  - [ ] Serialize source_urls to JSON
  - [ ] Add error handling (failures don't crash)
  - [ ] Add structlog logging

- [ ] Task 5: Integrate with QueryOrchestrator (AC: 5)
  - [ ] Add `QueryLogger` to QueryOrchestrator constructor
  - [ ] Call `asyncio.create_task(query_logger.log_query())` after process completes
  - [ ] Ensure fire-and-forget pattern (don't await)

- [ ] Task 6: Add structured logging (AC: 6)
  - [ ] Log successful saves with smalltalk flag
  - [ ] Log database errors
  - [ ] Include query_id for correlation

- [ ] Task 7: Write unit tests (AC: 7)
  - [ ] Test QueryLog model creation
  - [ ] Test QueryLog field validation
  - [ ] Test QueryLogRepository.create()
  - [ ] Test QueryLogRepository.get_recent()
  - [ ] Test QueryLogRepository.get_by_user()
  - [ ] Test QueryLogRepository.get_by_server()
  - [ ] Test QueryLogRepository.get_error_logs()
  - [ ] Test QueryLogRepository.get_smalltalk_queries()
  - [ ] Test QueryLogRepository.get_lore_queries()
  - [ ] Test QueryLogger successful logging
  - [ ] Test QueryLogger error handling
  - [ ] Test async non-blocking behavior

- [ ] Task 8: Test migration
  - [ ] Test `alembic upgrade head`
  - [ ] Test `alembic downgrade -1`
  - [ ] Verify rollback works correctly

## Dev Notes

### Technical Background
- **Async Logging:** Ensures query latency not impacted by database writes
- **Analytics Value:** Cost tracking (daily/weekly LLM spend monitoring)
- **Smalltalk Analytics:** Track smalltalk vs lore query ratio for user behavior insights
- **Error Logs:** Help identify patterns (which queries fail? which providers?)
- **Source URLs:** Logged for debugging and validation
- **Fire-and-Forget:** Acceptable because if log write fails, query still succeeds

### QueryLog Model Example
```python
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4

from sqlalchemy import Boolean, DateTime, Float, Integer, String, Text, Index
from sqlalchemy.dialects.sqlite import JSON
from sqlalchemy.orm import Mapped, mapped_column

from src.database import Base

class QueryLog(Base):
    """Query log model for analytics and debugging."""

    __tablename__ = "query_logs"

    id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid4)
    timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, index=True)
    user_id: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, index=True)
    server_id: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, index=True)
    query_text: Mapped[str] = mapped_column(Text)
    response_text: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    personality_reply: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    smalltalk: Mapped[bool] = mapped_column(Boolean, default=False, index=True)
    source_urls: Mapped[Optional[str]] = mapped_column(Text, nullable=True)  # JSON array
    chunks_retrieved: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)
    retrieval_scores: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)
    llm_provider: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)
    llm_model: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    llm_tokens_prompt: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    llm_tokens_completion: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    llm_cost_usd: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    latency_retrieval_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    latency_llm_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    latency_total_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    error_occurred: Mapped[bool] = mapped_column(Boolean, default=False, index=True)
    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    __table_args__ = (
        Index("ix_query_logs_timestamp_desc", timestamp.desc()),
    )
```

### QueryLogRepository Example
```python
from typing import Optional
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.query_log import QueryLog

class QueryLogRepository:
    """Repository for query log operations."""

    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, log: QueryLog) -> QueryLog:
        """Create a new query log entry."""
        self.session.add(log)
        await self.session.commit()
        await self.session.refresh(log)
        return log

    async def get_smalltalk_queries(self, limit: int = 50) -> list[QueryLog]:
        """Get recent smalltalk queries."""
        stmt = (
            select(QueryLog)
            .where(QueryLog.smalltalk == True)
            .order_by(QueryLog.timestamp.desc())
            .limit(limit)
        )
        result = await self.session.execute(stmt)
        return list(result.scalars().all())

    async def get_lore_queries(self, limit: int = 50) -> list[QueryLog]:
        """Get recent lore queries (non-smalltalk)."""
        stmt = (
            select(QueryLog)
            .where(QueryLog.smalltalk == False)
            .order_by(QueryLog.timestamp.desc())
            .limit(limit)
        )
        result = await self.session.execute(stmt)
        return list(result.scalars().all())
```

### QueryLogger Service Example
```python
import asyncio
import json
import structlog

from src.models.query_log import QueryLog
from src.repositories.query_log_repository import QueryLogRepository
from src.orchestration.query_orchestrator import QueryRequest, QueryResponse

logger = structlog.get_logger(__name__)

class QueryLogger:
    """Async query logging service."""

    def __init__(self, repository: QueryLogRepository):
        self.repository = repository

    async def log_query(
        self,
        request: QueryRequest,
        response: QueryResponse,
    ) -> None:
        """Log query to database (fire-and-forget)."""
        try:
            log = QueryLog(
                user_id=request.user_id,
                server_id=request.server_id,
                query_text=request.query_text,
                response_text=response.answer,
                personality_reply=response.personality_reply,
                smalltalk=response.smalltalk,
                source_urls=json.dumps(response.sources) if response.sources else None,
                llm_provider=response.metadata.get("provider"),
                llm_tokens_prompt=response.metadata.get("tokens_prompt"),
                llm_tokens_completion=response.metadata.get("tokens_completion"),
                llm_cost_usd=response.metadata.get("cost_usd"),
                latency_total_ms=response.metadata.get("latency_ms"),
                error_occurred=response.error is not None,
                error_message=response.error,
            )
            await self.repository.create(log)
            logger.info(
                "query_logged",
                smalltalk=response.smalltalk,
                error=response.error is not None,
            )
        except Exception as e:
            logger.error("query_log_failed", error=str(e))
            # Don't re-raise - logging failures shouldn't crash query flow
```

### Relevant Source Tree
```
src/models/
├── __init__.py                          # UPDATE: Export QueryLog
├── query_log.py                         # NEW: QueryLog model
src/repositories/
├── __init__.py                          # UPDATE: Export QueryLogRepository
├── query_log_repository.py              # NEW: QueryLogRepository
src/services/
├── __init__.py                          # UPDATE: Export QueryLogger
├── query_logger.py                      # NEW: QueryLogger service
alembic/versions/
├── xxx_add_query_logs_table.py          # NEW: Migration
tests/unit/
├── test_query_log.py                    # NEW: Model tests
├── test_query_log_repository.py         # NEW: Repository tests
├── test_query_logger.py                 # NEW: Service tests
```

### Analytics Queries (Future Use)
```sql
-- Smalltalk vs Lore ratio
SELECT
    smalltalk,
    COUNT(*) as count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage
FROM query_logs
WHERE timestamp > datetime('now', '-7 days')
GROUP BY smalltalk;

-- Daily cost tracking
SELECT
    DATE(timestamp) as date,
    SUM(llm_cost_usd) as total_cost,
    COUNT(*) as query_count
FROM query_logs
WHERE timestamp > datetime('now', '-30 days')
GROUP BY DATE(timestamp)
ORDER BY date DESC;

-- Error rate by provider
SELECT
    llm_provider,
    COUNT(*) as total,
    SUM(CASE WHEN error_occurred THEN 1 ELSE 0 END) as errors,
    ROUND(SUM(CASE WHEN error_occurred THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as error_rate
FROM query_logs
WHERE timestamp > datetime('now', '-7 days')
GROUP BY llm_provider;
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-09 | 1.0 | Story created from Epic 2 | John (PM Agent) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Pull Request
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_

---

**Estimated Effort:** 1.5 hours
